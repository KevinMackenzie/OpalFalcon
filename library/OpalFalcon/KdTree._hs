{-# LANGUAGE ExistentialQuantifications #-}
module OpalFalcon.KdTree (
    -- TODO: finish this
    KdTreeObjectType(inAABB, medPos),
    AxisAlignedBoundingBox) where

import OpalFalcon.Math.Vector
import qualified Data.Vector as V

-- Position(center) Size
data AxisAlignedBoundingBox = MkAABB Vec3d Vec3d

-- Splits a space (represented by an AABB) into two subspaces based on a split position
splitSpace :: KdAxis -> Vec3d -> AxisAlignedBoundingBox -> (AxisAlignedBoundingBox, AxisAlignedBoundingBox)
splitSpace a splitPos (MkAABB p s) = 
    (MkAABB (mutVecElem a p newVal1) (mutVecElem a s newValSize1),
     MkAABB (mutVecElem a p newVal2) (mutVecElem a s newValSize2))
    where splitVal = vecElem a splitPos 
          val = vecElem a p
          valSize = vecElem a s
          newValSize1 = (valSize/2) + (splitVal - val)
          newValSize2 = (valSize/2) - (splitVal - val)
          newVal1 = splitVal + (newValSize1 / 2)
          newVal2 = splitVal - (newValSize2 / 2)

-- Class of conservative functions to support volume objects in kd tree.  Balance construction time with runtime performance
class KdTreeObjectType a where
    -- Whether the object exists partially or totally within an AABB
    inAABB :: a -> AxisAlignedBoundingBox -> Bool
    -- The median position for all points in the object (volumetric).  Used for balancing the KD tree
    medPos :: a -> Vec3d

-- Allows for intra-tree polymorphism
data KdTreeObject = forall a . KdTreeObjectType a => MkTreeObj a

data KdAxis = KdX | KdY | KdZ

vecElem :: KdAxis -> Vec3 a -> a
vecElem KdX = xPos
vecElem KdY = yPos
vecElem KdZ = zPos

mutVecElem :: KdAxis -> Vec3 a -> a -> Vec3 a
mutVecElem KdX = mutX
mutVecElem KdY = mutY
mutVecElem KdZ = mutZ

depthAxis :: Integer -> KdAxis
depthAxis d = case d `mod` 3 of
                 0 -> KdX
                 1 -> KdY
                 2 -> KdZ

-- The photon type will have to be an alias of a fixed-length byte array... Haskell wasn't a good choice for this, but then we can do unboxed vectors of the prim byte array
-- Maybe it would be worth it to implement an "unboxed" KdTree for the photon maps (Prim types) that use unboxed vectors and one that uses "KdTreeObject"s to support sparce, heterogeneous contents
--
-- Or maybe, a BVH would be more suitable for non-point contents since K-d trees would have the same object in multiple nodes.

-- A 3-dimmensional k-d tree implemented using a tree
data KdTreeBase objType = KdLeaf (V.Vector KdTreeObject)
                        | KdNode KdAxis Double (KdTreeBase objType) (KdTreeBase objType)

-- pos (laziness!), index
data KdTreeIdxObject = MkKdTreeIdxObject Vec3d Int

-- A k-d tree that stores only indexes so that objects can exist in multiple nodes without duplication
--  Normally laziness would help here, but this lets us avoid duplicates easier (Or maybe GC does that anyway?)
data KdTree = 
    MkKdTree { kdTree :: KdTreeBase
             , objects :: V.Vector KdTreeObject
             , space ::AxisAlignedBoundingBox
             }

axisMerge :: KdAxis -> Vec3d -> KdTreeBase -> KdTreeBase -> KdTreeBase
axisMerge a p = KdNode a $ vecElem a p

mkKdTree':: AxisAlignedBoundingBox -> Int -> Integer -> V.Vector KdTreeObject -> KdTreeBase
mkKdTree' space' nodeCap depth elems = 
    if V.length elems < nodeCap then KdLeaf elems 
    else let axis = depthAxis depth
             medPos' = medPos $ (V.!) elems ((V.length elems) `div` 2)
             (laabb, raabb) = splitSpace axis medPos' space'
             l = V.filter (inAABB laabb) elems
             r = V.filter (inAABB raabb) elems
             genTree = mkKdTree' space' nodeCap (depth+1)
             lTree = genTree l
             rTree = genTree r
         in  axisMerge axis medPos' lTree rTree

-- TODO: this needs to use IdxKdTreeType
-- Creates a KdTree that supports point elements and elements with volume and in a finite space
mkKdTree :: AxisAlignedBoundingBox -> Int -> V.Vector KdTreeObject -> KdTree
mkKdTree space' nodeCap objects' = 
    let idxObjects = V.map (\(x,i) -> MkKdTreeIdxObject (medPos x) i) elems
    MkKdTree { kdTree = mkKdTree' space' nodeCap 0 objects'
             , objects = idxObjects
             , space = space'
             }

-- TODO: maybe allow for retrieving an AABB that a point lies in, or for enumerating all AABB's for debugging

-- Finds all objects within a radius of a position
collectObjects :: KdTree -> Vec3d -> Double -> [KdTreeObject]
collectObjects = undefined
-- Finds the 'n' closest objects to a position
closestObjects :: KdTree -> Int -> Vec3d -> [KdTreeObject]
closestObjects = undefined

